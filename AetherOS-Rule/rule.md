# AetherOS コーディング規約

## 1. 基本原則

### 1.1 コードの明瞭性と保守性
- **可読性優先**: コードは他の開発者が容易に理解できるように書くこと
- **自己文書化コード**: コードは可能な限り自己説明的であること
- **単一責任の原則**: 各関数、クラス、モジュールは単一の責任を持つこと
- **DRY原則**: 繰り返しを避け、コードの再利用を促進すること
- **KISS原則**: シンプルで直感的な解決策を優先すること

### 1.2 パフォーマンスと効率性
- **リソース効率**: メモリ、CPU、電力使用を最適化すること
- **早期最適化の回避**: 測定に基づかない最適化は避けること
- **スケーラビリティ考慮**: コードは将来の拡張に対応できるよう設計すること

### 1.3 セキュリティ
- **デフォルトでの安全性**: すべてのコードはセキュリティを前提に設計すること
- **入力検証**: すべての外部入力は検証し、安全に処理すること
- **最小権限の原則**: 必要最小限の権限でコードを実行すること

### 1.4 互換性と移植性
- **標準準拠**: 言語標準と業界ベストプラクティスに従うこと
- **プラットフォーム非依存**: 可能な限りプラットフォーム固有の機能に依存しないこと
- **下位互換性**: APIの変更は慎重に行い、互換性を維持すること

## 2. 言語固有のガイドライン

### 2.1 Rust
- **所有権モデル**: Rustの所有権とライフタイムモデルを尊重すること
- **安全性**: `unsafe`ブロックは必要な場合のみ使用し、徹底的に文書化すること
- **エラー処理**: `Result`と`Option`を適切に使用し、パニックを避けること
- **並行処理**: `Send`と`Sync`トレイトを理解し、データ競合を防止すること
- **コード構成**:
  ```rust
  // 良い例
  fn process_data(data: &[u8]) -> Result<Vec<u8>, ProcessError> {
      if data.is_empty() {
          return Err(ProcessError::EmptyInput);
      }
      
      let result = data.iter()
          .map(|&byte| transform_byte(byte))
          .collect::<Vec<_>>();
          
      Ok(result)
  }
  
  // 避けるべき例
  fn process_data(data: &[u8]) -> Vec<u8> {
      assert!(!data.is_empty(), "Empty input not allowed"); // パニックを引き起こす可能性
      
      let mut result = Vec::new();
      for byte in data {
          result.push(*byte + 1); // 変換ロジックがインライン化されている
      }
      
      result
  }
  ```

### 2.2 C/C++
- **メモリ管理**: 手動メモリ管理を最小限に抑え、スマートポインタを優先すること
- **例外処理**: 例外の使用を一貫させ、リソースリークを防止すること
- **型安全性**: 型キャストを最小限に抑え、`auto`を適切に使用すること
- **現代的機能**: C++17/20/23の機能を活用し、レガシーパターンを避けること
- **コード構成**:
  ```cpp
  // 良い例
  std::vector<int> processData(const std::vector<int>& data) {
      if (data.empty()) {
          throw std::invalid_argument("Empty input not allowed");
      }
      
      std::vector<int> result;
      result.reserve(data.size());
      
      std::transform(data.begin(), data.end(), std::back_inserter(result),
                    [](int value) { return transformValue(value); });
                    
      return result;
  }
  
  // 避けるべき例
  int* processData(int* data, int size) {
      if (!data || size <= 0) return NULL;
      
      int* result = (int*)malloc(size * sizeof(int));
      if (!result) return NULL;
      
      for (int i = 0; i < size; i++) {
          result[i] = data[i] + 1;
      }
      
      return result; // 呼び出し側で解放する必要がある
  }
  ```

### 2.3 Python
- **PEP 8**: Python公式スタイルガイドに従うこと
- **型ヒント**: 型ヒントを使用して可読性と静的解析を向上させること
- **コンテキストマネージャ**: リソース管理に`with`文を使用すること
- **イテレータとジェネレータ**: 大きなデータセットにはジェネレータを使用すること
- **コード構成**:
  ```python
  # 良い例
  def process_data(data: List[int]) -> List[int]:
      """入力データを処理し、変換された結果を返す。
      
      Args:
          data: 処理する整数のリスト
          
      Returns:
          変換された整数のリスト
          
      Raises:
          ValueError: 入力が空の場合
      """
      if not data:
          raise ValueError("Empty input not allowed")
          
      return [transform_value(x) for x in data]
      
  # 避けるべき例
  def process_data(data):
      assert data, "Empty input not allowed"
      
      result = []
      for x in data:
          result.append(x + 1)
          
      return result
  ```

### 2.4 Go
- **エラー処理**: エラーを明示的に処理し、無視しないこと
- **並行処理**: ゴルーチンとチャネルを適切に使用し、リソースリークを防止すること
- **インターフェース**: 小さく焦点を絞ったインターフェースを設計すること
- **コード構成**:
  ```go
  // 良い例
  func ProcessData(data []int) ([]int, error) {
      if len(data) == 0 {
          return nil, errors.New("empty input not allowed")
      }
      
      result := make([]int, 0, len(data))
      for _, value := range data {
          result = append(result, transformValue(value))
      }
      
      return result, nil
  }
  
  // 避けるべき例
  func ProcessData(data []int) []int {
      if len(data) == 0 {
          panic("empty input not allowed") // パニックを避ける
      }
      
      var result []int // 容量を事前に割り当てていない
      for i := 0; i < len(data); i++ {
          result = append(result, data[i] + 1)
      }
      
      return result
  }
  ```

## 3. コードスタイルと形式

### 3.1 命名規則
- **一貫性**: プロジェクト全体で一貫した命名規則を使用すること
- **説明的**: 名前は目的と使用法を明確に示すこと
- **略語の回避**: 一般的に認識されている場合を除き、略語を避けること
- **言語固有の慣習**:
  - Rust: スネークケース (`snake_case`) を変数と関数に、キャメルケース (`CamelCase`) を型に使用
  - C++: キャメルケース (`camelCase`) を変数と関数に、パスカルケース (`PascalCase`) をクラスに使用
  - Python: スネークケース (`snake_case`) を変数と関数に、パスカルケース (`PascalCase`) をクラスに使用
  - Go: キャメルケース (`camelCase`) を非公開要素に、パスカルケース (`PascalCase`) を公開要素に使用

### 3.2 コメントとドキュメント
- **目的**: コメントは「なぜ」に焦点を当て、コードは「何」と「どのように」を示すこと
- **API文書**: すべての公開APIは完全に文書化すること
- **更新**: コメントはコードと共に更新し、誤解を避けること
- **言語固有のドキュメント**:
  - Rust: Rustdocスタイルのコメント (`///` と `//!`) を使用
  - C++: Doxygen/Javadocスタイルのコメントを使用
  - Python: Docstringsを使用し、Google/NumPy/reST形式に従う
  - Go: Godocの慣習に従う

### 3.3 コード形式
- **一貫性**: 自動フォーマッタを使用して一貫性を確保すること
- **行の長さ**: 行の長さは80-120文字に制限すること
- **インデント**: 言語の慣習に従い、タブまたはスペースを一貫して使用すること
- **空白**: 読みやすさを向上させるために適切な空白を使用すること
- **言語固有のフォーマッタ**:
  - Rust: `rustfmt`
  - C++: `clang-format`
  - Python: `black`、`isort`
  - Go: `gofmt`、`goimports`

## 4. コード品質と検証

### 4.1 テスト
- **テスト範囲**: すべての公開APIと重要なロジックにテストを書くこと
- **テスト種類**: ユニットテスト、統合テスト、プロパティベーステスト、ファジングを適切に使用すること
- **テスト独立性**: テストは独立して実行でき、順序に依存しないこと
- **テスト可読性**: テストは意図と期待される結果を明確に示すこと
- **言語固有のテストフレームワーク**:
  - Rust: `cargo test`、`proptest`、`quickcheck`
  - C++: `Google Test`、`Catch2`、`Boost.Test`
  - Python: `pytest`、`unittest`、`hypothesis`
  - Go: 標準の`testing`パッケージ、`testify`

### 4.2 静的解析
- **リンター**: 言語固有のリンターを使用して一般的な問題を検出すること
- **型チェック**: 可能な限り静的型チェックを活用すること
- **セキュリティスキャン**: セキュリティ脆弱性を検出するためのツールを使用すること
- **言語固有のツール**:
  - Rust: `clippy`、`rust-analyzer`
  - C++: `clang-tidy`、`cppcheck`、`PVS-Studio`
  - Python: `pylint`、`mypy`、`pyright`、`bandit`
  - Go: `golangci-lint`、`staticcheck`

### 4.3 コードレビュー
- **焦点**: 機能性、保守性、パフォーマンス、セキュリティに焦点を当てること
- **建設的**: 問題だけでなく、改善提案も提供すること
- **効率的**: 小さな変更を頻繁にレビューし、大きな変更を避けること
- **チェックリスト**: 一貫したレビュープロセスのためにチェックリストを使用すること

## 5. 特殊領域のガイドライン

### 5.1 並行処理と並列処理
- **データ競合**: 共有状態へのアクセスを同期し、データ競合を防止すること
- **デッドロック**: リソースの循環依存を避け、デッドロックを防止すること
- **スケーラビリティ**: 並列処理のオーバーヘッドとスケーラビリティの限界を考慮すること
- **言語固有のパターン**:
  - Rust: `Arc`、`Mutex`、`RwLock`、`Rayon`、`async`/`await`
  - C++: `std::thread`、`std::mutex`、`std::atomic`、`std::future`
  - Python: `threading`、`multiprocessing`、`asyncio`
  - Go: ゴルーチン、チャネル、`sync`パッケージ

### 5.2 リソース管理
- **RAII**: リソース獲得は初期化であるパターンを使用すること
- **リソース制限**: リソース使用に上限を設け、過剰消費を防止すること
- **クリーンアップ**: すべてのリソースが適切に解放されることを確認すること
- **言語固有のパターン**:
  - Rust: 所有権システム、`Drop`トレイト
  - C++: スマートポインタ、RAII、移動セマンティクス
  - Python: コンテキストマネージャ、`with`文
  - Go: `defer`文

### 5.3 エラー処理
- **回復可能なエラー**: 回復可能なエラーは明示的に処理し、プログラムの継続を可能にすること
- **回復不能なエラー**: 回復不能なエラーは適切に記録し、安全に終了すること
- **エラー伝播**: エラーは適切なレベルで処理されるまで伝播させること
- **言語固有のパターン**:
  - Rust: `Result`、`Option`、`?`演算子
  - C++: 例外、`std::optional`、`std::expected`
  - Python: 例外、`try`/`except`/`finally`
  - Go: 複数戻り値、明示的エラーチェック、`errors`パッケージ

### 5.4 パフォーマンス最適化
- **測定**: 最適化前に性能をプロファイリングし、ボトルネックを特定すること
- **アルゴリズム**: データ構造とアルゴリズムの選択を慎重に行うこと
- **キャッシュ**: メモリ階層を考慮し、キャッシュ効率を最適化すること
- **言語固有の最適化**:
  - Rust: ゼロコスト抽象化、インライン化、SIMD
  - C++: テンプレートメタプログラミング、移動セマンティクス、SIMD
  - Python: C拡張、NumPy/Pandas、JIT (Numba)
  - Go: メモリアロケーション最小化、ゴルーチンプール

## 6. 持続可能な開発

### 6.1 技術的負債
- **認識**: 技術的負債を認識し、文書化すること
- **管理**: 技術的負債を定期的に返済する計画を立てること
- **防止**: 新しい技術的負債の発生を最小限に抑えること

### 6.2 リファクタリング
- **継続的改善**: コードベースを継続的に改善し、品質を維持すること
- **スコープ**: リファクタリングの範囲を明確に定義し、機能変更と分離すること
- **検証**: リファクタリング後にテストを実行し、動作が変わっていないことを確認すること

### 6.3 ドキュメント
- **最新性**: ドキュメントを最新の状態に保ち、コードと同期させること
- **包括性**: アーキテクチャ、設計決定、APIを文書化すること
- **アクセシビリティ**: ドキュメントは検索可能で、理解しやすいこと

## 7. セキュリティとプライバシー

### 7.1 セキュアコーディング
- **入力検証**: すべての外部入力を検証し、安全に処理すること
- **出力エンコード**: コンテキストに応じて出力を適切にエンコードすること
- **機密データ**: 機密データの処理と保存に特別な注意を払うこと
- **言語固有のセキュリティ**:
  - Rust: メモリ安全性、`#[forbid(unsafe_code)]`
  - C++: RAII、スマートポインタ、境界チェック
  - Python: 入力検証、パラメータ化クエリ
  - Go: コンテキスト対応API、入力検証

### 7.2 暗号化
- **標準アルゴリズム**: 検証済みの暗号化アルゴリズムとライブラリを使用すること
- **鍵管理**: 暗号鍵を安全に生成、保存、更新すること
- **ランダム性**: 暗号学的に安全な乱数生成器を使用すること

### 7.3 プライバシー
- **データ最小化**: 必要最小限のデータのみを収集し処理すること
- **同意**: ユーザーデータの収集と使用に対する明示的な同意を得ること
- **匿名化**: 可能な限りデータを匿名化または仮名化すること

## 8. 継続的改善

### 8.1 メトリクス
- **コード品質**: 複雑性、凝集度、結合度などのメトリクスを追跡すること
- **パフォーマンス**: 実行時間、メモリ使用量、レイテンシなどを測定すること
- **プロセス**: リードタイム、デプロイ頻度、障害率などを監視すること

### 8.2 フィードバックループ
- **レビュー**: コードレビューからのフィードバックを積極的に取り入れること
- **テスト**: テスト結果を分析し、品質向上に活用すること
- **ユーザー**: エンドユーザーからのフィードバックを収集し、優先順位付けすること

### 8.3 知識共有
- **ペアプログラミング**: 知識移転と品質向上のためにペアプログラミングを実践すること
- **文書化**: 設計決定と学んだ教訓を文書化すること
- **トレーニング**: チーム全体のスキル向上のためのトレーニングを提供すること

## 9. 環境固有のガイドライン

### 9.1 組み込みシステム
- **リソース制約**: メモリと処理能力の制約を考慮すること
- **決定論的動作**: 予測可能な実行時間と動作を確保すること
- **電力効率**: バッテリー寿命を最大化するためにコードを最適化すること

### 9.2 分散システム
- **部分的障害**: ネットワーク分断や部分的障害に対処すること
- **一貫性モデル**: 適切な一貫性モデルを選択し、トレードオフを理解すること
- **スケーラビリティ**: 水平スケーリングと負荷分散を考慮すること

### 9.3 高性能コンピューティング
- **データ局所性**: キャッシュ効率とデータ局所性を最適化すること
- **並列化**: 効率的な並列処理アルゴリズムを使用すること
- **ベクトル化**: SIMD命令を活用してデータ並列処理を最適化すること

## 10. コンプライアンスと標準

### 10.1 業界標準
- **コーディング標準**: 業界固有のコーディング標準に準拠すること
- **セキュリティ標準**: OWASP、CWE、NISTなどのセキュリティガイドラインに従うこと
- **アクセシビリティ**: WCAG、ADA、Section 508などのアクセシビリティ要件に準拠すること

### 10.2 法的コンプライアンス
- **ライセンス**: オープンソースライセンスの要件を遵守すること
- **データ保護**: GDPR、CCPA、HIPAAなどのデータ保護法に準拠すること
- **輸出規制**: 暗号技術に関する輸出規制を遵守すること

### 10.3 内部標準
- **アーキテクチャ**: 定義されたアーキテクチャパターンと設計原則に従うこと
- **技術スタック**: 承認された技術とライブラリを使用すること
- **開発プロセス**: 定義された開発ライフサイクルとレビュープロセスに従うこと
